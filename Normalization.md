Все созданные выше таблицы находятся как минимум в 2NF, а большая часть в BCNF. Такой результат получен благодаря тому, что сначала была создана ER-модель, затем прописаны функциональные зависимости, а только потом создавались таблицы. 
Однако в изначальном варианте таблицы UnplannedMeeting и Overthrow не удовлетворяли даже 3NF (но всё ещё находились в 2NF). В обеих таблицах проблемой было наличие в них столбца (атрибута) StrategistID, который зависел от столбца (атрибута) AppointmentDate, что нарушало условие 3NF, которое не допускает транзитивную зависимость неключевого атрибута от первичного ключа. Разберём процесс нормализации данных таблиц на примере таблицы UnplannedMeeting. Решением проблемы стало исключение из таблицы проблемного столбца StrategistID. Таким образом, единственным неключевым атрибутом в таблице остался AppointmentDate, который зависит от первичного ключа HoldingDate, что гарантирует BCNF. Аналогично проблема была решена и в таблице Overthrow. При этом не была потеряна функциональная зависимость AppointmentDate → StrategistID, которая сохраняется в таблице Strategist.
Другой недонормализованной таблицей была Official, которая выглядела следующим образом: Official(OfficialID, AppointmentDate, FactDismissalDate, PostName, PlannedDissmissalDate). Проблема в том, что в изначальной версии ER-модели не было сущности “Должности”, а у сущности “Госдеятели” было 4 атрибута (не считая наследуемый ID): Дата вступления в должность (AppointmentDate), фактическая дата ухода с должности (FactDismissalDate), планируемая дата ухода с должности (PlannedDissmissalDate), название должности (PostName). Однако было выяснено, что существует функциональная зависимость AppointmentDate, PostName → PlannedDissmissalDate. Идейно это означало, что у каждой должности есть свой определенный срок, на который госдеятель избирается на эту должность (см. Ограничения данных, п.9). Поэтому было принято решение создать новую сущность “Должности” и соответствующим образом реструктурировать ER-модель (см. ER-модель).  На уровне таблиц это изменение отразилось созданием отдельной таблицы для функциональной зависимости PostName → Duration (бывшая AppointmentDate, PostName → PlannedDissmissalDate), что устранило транзитивную зависимость Duration от первичного ключа таблицы (OfficialID, AppointmentDate). Обе таблицы теперь находятся в BCNF.

Аномалии
Выше был описан процесс нормализации трёх таблиц, которые изначально были в 2NF, до BCNF. Однако есть ещё одна недонормализованная таблица Meeting. В этой таблице неключевой атрибут Category зависит от неключевого атрибута Agenda. Эта функциональная зависимость нарушает условие 3NF. Решением данной проблемы может стать создание отдельной таблицы для упомянутой функциональной зависимости. Однако было решено, что это нерационально по нескольким причинам:
1)	Аномалия обновления крайне маловероятна, так как минимален шанс появления двух абсолютно одинаковых полей в столбце Agenda, по той причине, что в данном столбце содержатся произвольные (нестандартизированные) тексты. Поэтому, если понадобится обновить Category для некоторой конкретной Agenda, с очень большой вероятностью не придется искать в таблице другую запись с такой же Agenda, чтобы обновить у неё Category, так как её, скорее всего, не будет существовать. Однако, теоретически, аномалия обновления может возникнуть, из-за чего появится несогласованность данных.
2)	Аномалии удаления не опасна, так как невозможно потерять лишние данные при удалении некоторой записи.
3)	Аномалии вставки также в нашем случае не существует.
4)	Создание отдельной таблицы, где фактически будут дублироваться все тексты обсуждаемой повестки (Agenda), которые, с одной стороны, относительно тяжелые, а с другой стороны, почти уникальны, приведет к ненужной трате дискового пространства, а также усложнит и замедлит выполнение определённых запросов (связанных с обработкой информации о категориях повесток Category).
Примером, когда недонормализованность действительно приводит к появлению аномалий, будет являться таблица, объединяющая существующие таблицы Warrior и Fight. Идея таблицы: хранить в одном месте информацию о воинах и кампаниях, где они участвовали. Выглядеть она будет так: WarriorFight(WarriorID, RecruitmentDate, PlannedRetirementDate, FactRetirementDate, CampaignName ). Тогда, если воин погибнет на войне, возникнет необходимость поменять его FactRetirementDate с NULL на фактическую дату смерти. Однако необходимо будет учитывать, что этот воин мог участвовать в нескольких военных кампаниях за время своей службы, из-за чего есть риск возникновения аномалии обновления, если данные о FactRetirementDate в старых военных кампаниях не будут изменены.
